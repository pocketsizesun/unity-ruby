#!/usr/bin/env ruby

require 'bundler/setup'
require 'optparse'
require 'unity'

orig_args = ARGV.dup
command = ARGV.shift

case command
when 'console', 'c'
  ENV['UNITY_CONSOLE'] = '1'
  require_relative "#{Dir.pwd}/config/boot.rb"
  require 'pry'

  def reload!
    exec '/usr/bin/env', 'bundle', 'exec', 'unity', 'console'
  end

  Pry.start
when 'runner', 'r'
  require_relative "#{Dir.pwd}/config/boot.rb"

  load ARGV.shift
when 'server', 's'
  options = { reload: false }
  OptionParser.new do |opts|
    opts.on('-r', '--reload', 'Auto-reload when file changes') do
      options[:reload] = true
    end
  end.parse!

  if options[:reload] == true
    exec '/usr/bin/env', 'bundle', 'exec', 'rerun', 'bundle exec puma'
  else
    exec '/usr/bin/env', 'bundle', 'exec', 'puma'
  end
when 'event:consumer'
  options = { reload: false, concurrency: 2, workers_count: 2 }
  argv_dup = ARGV.dup.reject { |v| v == '--reload' }
  OptionParser.new do |opts|
    opts.on('-e', '--environment=NAME', 'Application environment (default: development)') do |v|
      ENV['UNITY_ENV'] = v.to_s
    end

    opts.on('-q', '--queue=NAME', 'Event stream SQS queue name') do |v|
      options[:queue] = v.to_s
    end

    opts.on('-c', '--concurrency=COUNT', 'Number of threads per worker (default: 2)') do |v|
      options[:concurrency] = v.to_i
    end

    opts.on('-w', '--workers=COUNT', 'Number of workers (default: 2)') do |v|
      options[:workers_count] = v.to_i
    end

    opts.on('--reload', 'Auto-reload when file changes') do
      options[:reload] = true
    end
  end.parse!

  abort '[event:consumer] Queue not specified' if options[:queue].nil?

  if options[:reload] == true
    exec '/usr/bin/env', 'bundle', 'exec', 'rerun', "bundle exec unity event:consumer #{argv_dup.join(' ')}"
  end

  require_relative "#{Dir.pwd}/config/boot.rb"
  require 'unity/event_consumer'

  Unity::EventConsumer.run(options)
else
  exec '/usr/bin/env', 'bundle', 'exec', 'rake', '--rakefile', "#{Dir.pwd}/Rakefile", *orig_args
end
